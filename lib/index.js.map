{"version":3,"sources":["../src/index.js"],"names":["amqp","require","path","logstashWinston","global","logger","env","process","NODE_ENV","currentPath","cwd","config","join","host","port","username","password","vhost","protocol","prefetch","heartbeatInterval","reconnectTime","options","defaultQueueFeatures","durable","rabbitMQ","connectionUrl","connection","connect","json","heartbeatIntervalInSeconds","reconnectTimeInSeconds","connectionOptions","on","log","note","params","error","err","consume","handler","queueName","queue","name","queueOptions","Promise","reject","Error","channelWrapper","createChannel","setup","channel","all","assertQueue","data","message","JSON","parse","content","toString","then","ack","catch","noAck","e","waitForConnect","publish","startPublishing","sendToQueue","persistent","resolve","custom","close","purgeQueue","ackAll","module","exports"],"mappings":"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","file":"index.js","sourcesContent":["const amqp = require('amqp-connection-manager');\nconst path = require('path');\nconst logstashWinston = require('logstash-winston');\n\nglobal.logger = logstashWinston.logger;\n\nconst env = process.env.NODE_ENV || 'development';\nconst currentPath = process.cwd();\n\nconst config = require(path.join(currentPath, 'config', 'env', `${env}`));\n\nconst {\n    host,\n    port,\n    username,\n    password,\n    vhost = '/',\n    protocol = 'amqp',\n    prefetch = 2,\n    heartbeatInterval = 5,\n    reconnectTime = 10,\n    options = {},\n    defaultQueueFeatures = { durable: true }\n} = config.rabbitMQ;\n\nconst connectionUrl = `${protocol}://${username}:${password}@${host}:${port}/${vhost}`;\n\n/**\n * options.heartbeatIntervalInSeconds - Interval to send heartbeats to broker. Defaults to 5 seconds.\n * options.reconnectTimeInSeconds - The time to wait before trying to reconnect. If not specified, defaults to heartbeatIntervalInSeconds.\n * options.findServers(callback) is a function which returns one or more servers to connect to. This should return either a single URL or an array of URLs. This is handy when you're using a service discovery mechanism such as Consul or etcd. Instead of taking a callback, this can also return a Promise. Note that if this is supplied, then urls is ignored.\n * options.connectionOptions is passed as options to the amqplib connect method.\n */\n\n// Create a connetion manager\nconst connection = amqp.connect(\n  [connectionUrl],\n  {\n    json: true,\n    heartbeatIntervalInSeconds: heartbeatInterval,\n    reconnectTimeInSeconds: reconnectTime,\n    connectionOptions: options\n  }\n);\n\nconnection.on('connect', () => {\n  logger.log('data', { note: 'Connected to RabbitMQ server' });\n});\n\nconnection.on('disconnect', params => {\n  logger.log('error', { error: params.err, note: 'RabbitMQ server is disconnected' });\n});\n\n/**\n *  Consumer.\n *\n * @param {object} params - object with queue name and queue options.\n * @param {function} [handler] - callback.\n * @returns {void | Promise} - Resolves when complete.\n */\nconst consume = (params = {}, handler) => {\n  const queueName = params.queue && params.queue.name;\n  const queueOptions = params.queue.options || defaultQueueFeatures;\n\n  if (!queueName) {\n    return Promise.reject(new Error('Queue name is missing'));\n  }\n\n  // Set up a channel listening for messages in the queue.\n  const channelWrapper = connection.createChannel({\n    setup(channel) {\n      // `channel` here is a regular amqplib `ConfirmChannel`.\n      return Promise.all([\n        channel.assertQueue(queueName, queueOptions),\n        channel.prefetch(prefetch),\n        channel.consume(\n          queueName,\n          data => {\n            const message = JSON.parse(data.content.toString());\n\n            handler(message).then(() => channelWrapper.ack(data)).catch(() => {});\n          },\n          { noAck: false }\n        )\n      ]).catch(e => {\n        logger.log('error', { error: e, note: 'error from consume' });\n      });\n    }\n  });\n\n  /** start the consumer */\n  return channelWrapper.waitForConnect().then(() => {\n    logger.log('data', { note: `Consumption from ${queueName} started!` });\n  });\n};\n\n/**\n *  Publisher.\n *\n * @param {object} params - object with queue name and queue options.\n * @param {object} [data] - data to be published.\n * @returns {void | Promise} - Resolves when complete.\n */\nconst publish = (params = {}, data) => {\n  const queueName = params.queue && params.queue.name;\n  const queueOptions = params.queue.options || defaultQueueFeatures;\n\n  if (!queueName) {\n    return Promise.reject(new Error('Queue name is missing'));\n  }\n\n  const channelWrapper = connection.createChannel({\n    json: true,\n    setup(channel) {\n      // `channel` here is a regular amqplib `ConfirmChannel`.\n      return channel.assertQueue(queueName, queueOptions);\n    }\n  });\n\n  const startPublishing = () => {\n    channelWrapper\n      .sendToQueue(queueName, data, { persistent: true })\n      .then(() => {\n        logger.log('data', { note: `Message sent to queue ${queueName}` });\n        return Promise.resolve(data);\n      })\n      .catch(err => {\n        logger.log('error', { note: 'Message was rejected', error: err, custom: { data }});\n        channelWrapper.close();\n        connection.close();\n      });\n  };\n\n  startPublishing();\n};\n\n/**\n *  purgeQueue.\n *\n * @param {object} params - object with queue name and queue options.\n * @returns {void | Promise} - Resolves when complete.\n */\nconst purgeQueue = (params ={}) => {\n  const queueName = params.queue && params.queue.name;\n  const queueOptions = params.queue.options || defaultQueueFeatures;\n\n  if (!queueName) {\n    return Promise.reject(new Error('Queue name is missing'));\n  }\n\n  const channelWrapper = connection.createChannel({\n    setup(channel) {\n      // `channel` here is a regular amqplib `ConfirmChannel`.\n      return Promise.all([\n        channel.assertQueue(queueName, queueOptions),\n        channel.purgeQueue(queueName)\n      ]);\n    }\n  });\n\n  return channelWrapper;\n};\n\n/**\n *  ackAll.\n *\n * @returns {void | Promise} - Resolves when complete.\n */\nconst ackAll = () => {\n  const channelWrapper = connection.createChannel({\n    setup(channel) {\n      // `channel` here is a regular amqplib `ConfirmChannel`.\n      return channel.ackAll();\n    }\n  });\n\n  return channelWrapper;\n};\n\nmodule.exports = {\n  publish,\n  consume,\n  purgeQueue,\n  ackAll\n};\n"]}