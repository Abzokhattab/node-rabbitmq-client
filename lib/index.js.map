{"version":3,"sources":["../src/index.js"],"names":["connect","urls","options","AmqpConnectionManager","amqp","env","process","NODE_ENV","currentPath","cwd","config","require","path","join","console","log","host","port","username","password","vhost","protocol","rabbitMQ","connectionUrl","connection","json","on","params","err","stack","consume","queueName","handler","channelWrapper","createChannel","setup","channel","Promise","all","assertQueue","durable","prefetch","data","message","JSON","parse","content","toString","then","ack","catch","noAck","e","error","waitForConnect","publish","startPublishing","sendToQueue","persistent","resolve","close","purgeQueue","ackAll","module","exports"],"mappings":";;;;;QAGgBA,O,GAAAA,O;;AAHhB;;;;AACA;;;;;;AAEO,SAASA,OAAT,CAAiBC,IAAjB,EAAuBC,OAAvB,EAAgC;AACnC,SAAO,IAAIC,+BAAJ,CAA0BF,IAA1B,EAAgCC,OAAhC,CAAP;AACH;;AAED,MAAME,OAAO;AACTJ;AADS,CAAb;;AAIA;AACA,MAAMK,MAAMC,QAAQD,GAAR,CAAYE,QAAZ,IAAwB,aAApC;AACA,MAAMC,cAAcF,QAAQG,GAAR,EAApB;AACA,MAAMC,SAASC,QAAQC,eAAKC,IAAL,CAAUL,WAAV,EAAuB,QAAvB,EAAiC,KAAjC,EAAyC,GAAEH,GAAI,EAA/C,CAAR,CAAf;AACAS,QAAQC,GAAR,CAAYL,MAAZ;;AAEA;AACA,MAAM,EAAEM,IAAF,EAAQC,IAAR,EAAcC,QAAd,EAAwBC,QAAxB,EAAkCC,KAAlC,EAAyCC,WAAW,MAApD,KAA+DX,OAAOY,QAA5E;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,gBAAiB,GAAEF,QAAS,MAAKH,QAAS,IAAGC,QAAS,IAAGH,IAAK,IAAGC,IAAK,IAAGG,KAAM,EAArF;;AAEA;;;;;;;AAOA;AACA,MAAMI,aAAaxB,QACjB,CAACuB,aAAD,CADiB,EAEjB,EAAEE,MAAM,IAAR,EAFiB,CAAnB;;AAKAX,QAAQC,GAAR,CAAYS,UAAZ;;AAEAA,WAAWE,EAAX,CAAc,SAAd,EAAyB,MAAM;AAC7BZ,UAAQC,GAAR,CAAY,YAAZ;AACD,CAFD;AAGAS,WAAWE,EAAX,CAAc,YAAd,EAA4BC,UAAU;AACpCb,UAAQC,GAAR,CAAY,eAAZ,EAA6BY,OAAOC,GAAP,CAAWC,KAAxC;AACD,CAFD;;AAIA;;;;;;;AAOA,MAAMC,UAAU,CAACC,SAAD,EAAYC,OAAZ,KAAwB;AACtC;AACA,QAAMC,iBAAiBT,WAAWU,aAAX,CAAyB;AAC9CC,UAAMC,OAAN,EAAe;AACb;AACA,aAAOC,QAAQC,GAAR,CAAY,CACjBF,QAAQG,WAAR,CAAoBR,SAApB,EAA+B,EAAES,SAAS,IAAX,EAA/B,CADiB,EAEjBJ,QAAQK,QAAR,CAAiB,CAAjB,CAFiB;AAGjB;AACAL,cAAQN,OAAR,CACEC,SADF,EAEEW,QAAQ;AACN,cAAMC,UAAUC,KAAKC,KAAL,CAAWH,KAAKI,OAAL,CAAaC,QAAb,EAAX,CAAhB;;AAEAf,gBAAQW,OAAR,EAAiBK,IAAjB,CAAsB,MAAMf,eAAegB,GAAf,CAAmBP,IAAnB,CAA5B,EAAsDQ,KAAtD,CAA4D,MAAM,CAAE,CAApE;AACD,OANH,EAOE,EAAEC,OAAO,KAAT,EAPF,CAJiB,CAAZ,EAaJD,KAbI,CAaEE,KAAK;AACZtC,gBAAQuC,KAAR,CAAcD,CAAd;AACD,OAfM,CAAP;AAgBD;AAnB6C,GAAzB,CAAvB;;AAsBA;AACA,SAAOnB,eAAeqB,cAAf,GAAgCN,IAAhC,CAAqC,MAAM;AAChDlC,YAAQC,GAAR,CAAa,6BAA4BgB,SAAU,EAAnD;AACD,GAFM,CAAP;AAGD,CA5BD;;AA8BA;;;;;;AAMA,MAAMwB,UAAU,CAACxB,SAAD,EAAYW,IAAZ,KAAqB;AACnC5B,UAAQC,GAAR,CAAYgB,SAAZ,EAAuBW,IAAvB;AACA,QAAMT,iBAAiBT,WAAWU,aAAX,CAAyB;AAC9CT,UAAM,IADwC;AAE9CU,UAAMC,OAAN,EAAe;AACb;AACA,aAAOA,QAAQG,WAAR,CAAoBR,SAApB,EAA+B,EAAES,SAAS,IAAX,EAA/B,CAAP;AACD;AAL6C,GAAzB,CAAvB;;AAQA;AACA,QAAMgB,kBAAkB,MAAM;AAC5BvB,mBACGwB,WADH,CACe1B,SADf,EAC0BW,IAD1B,EACgC,EAAEgB,YAAY,IAAd,EADhC,EAEGV,IAFH,CAEQ,MAAM;AACVlC,cAAQC,GAAR,CAAY,cAAZ;AACA;AACA,aAAO,IAAP;AACD,KANH,EAOGiC,IAPH,CAOQ;AACJ;AACAX,YAAQsB,OAAR,EATJ,EAWGT,KAXH,CAWStB,OAAO;AACZd,cAAQC,GAAR,CAAY,uBAAZ,EAAqCa,IAAIC,KAAzC;AACAI,qBAAe2B,KAAf;AACApC,iBAAWoC,KAAX;AACD,KAfH;AAgBD,GAjBD;;AAmBAJ;;AAEA;AACD,CAjCD;;AAmCA,MAAMK,aAAa9B,aAAa;AAC9B,QAAME,iBAAiBT,WAAWU,aAAX,CAAyB;AAC9CC,UAAMC,OAAN,EAAe;AACb;AACA,aAAOC,QAAQC,GAAR,CAAY,CACjBF,QAAQG,WAAR,CAAoBR,SAApB,EAA+B,EAAES,SAAS,IAAX,EAA/B,CADiB,EAEjBJ,QAAQyB,UAAR,CAAmB9B,SAAnB,CAFiB,CAAZ,CAAP;AAID;AAP6C,GAAzB,CAAvB;;AAUA,SAAOE,cAAP;AACD,CAZD;;AAcA,MAAM6B,SAAS,MAAM;AACnB,QAAM7B,iBAAiBT,WAAWU,aAAX,CAAyB;AAC9CC,UAAMC,OAAN,EAAe;AACb;AACA,aAAOA,QAAQ0B,MAAR,EAAP;AACD;AAJ6C,GAAzB,CAAvB;;AAOA,SAAO7B,cAAP;AACD,CATD;;AAWA8B,OAAOC,OAAP,GAAiB;AACfT,SADe;AAEfzB,SAFe;AAGf+B,YAHe;AAIfC;AAJe,CAAjB;;kBAOe1D,I","file":"index.js","sourcesContent":["import AmqpConnectionManager from './AmqpConnectionManager';\nimport path from 'path';\n\nexport function connect(urls, options) {\n    return new AmqpConnectionManager(urls, options);\n}\n\nconst amqp = {\n    connect\n};\n\n// export default amqp;\nconst env = process.env.NODE_ENV || 'development';\nconst currentPath = process.cwd();\nconst config = require(path.join(currentPath, 'config', 'env', `${env}`));\nconsole.log(config);\n\n// const QUEUE_NAME = 'amqp-connection-manager-sample'\nconst { host, port, username, password, vhost, protocol = 'amqp' } = config.rabbitMQ;\n\n// Handle an incomming message.\n// const onMessage = function(channelWrapper, data) {\n//   const message = JSON.parse(data.content.toString());\n//   console.log(\"receiver: got message\", message);\n//   channelWrapper.ack(data);\n// }\n\nconst connectionUrl = `${protocol}://${username}:${password}@${host}:${port}/${vhost}`;\n\n/**\n * options.heartbeatIntervalInSeconds - Interval to send heartbeats to broker. Defaults to 5 seconds.\n * options.reconnectTimeInSeconds - The time to wait before trying to reconnect. If not specified, defaults to heartbeatIntervalInSeconds.\n * options.findServers(callback) is a function which returns one or more servers to connect to. This should return either a single URL or an array of URLs. This is handy when you're using a service discovery mechanism such as Consul or etcd. Instead of taking a callback, this can also return a Promise. Note that if this is supplied, then urls is ignored.\n * options.connectionOptions is passed as options to the amqplib connect method.\n */\n\n// Create a connetion manager\nconst connection = connect(\n  [connectionUrl],\n  { json: true }\n);\n\nconsole.log(connection);\n\nconnection.on('connect', () => {\n  console.log('Connected!');\n});\nconnection.on('disconnect', params => {\n  console.log('Disconnected.', params.err.stack);\n});\n\n/**\n *  Consumer.\n *\n * @param {string} queueName - name of queue.\n * @param {function} [handler] - callback.\n * @returns {void | Promise} - Resolves when complete.\n */\nconst consume = (queueName, handler) => {\n  // Set up a channel listening for messages in the queue.\n  const channelWrapper = connection.createChannel({\n    setup(channel) {\n      // `channel` here is a regular amqplib `ConfirmChannel`.\n      return Promise.all([\n        channel.assertQueue(queueName, { durable: true }),\n        channel.prefetch(1),\n        // channel.consume(queueName, handler.bind(null, channelWrapper))\n        channel.consume(\n          queueName,\n          data => {\n            const message = JSON.parse(data.content.toString());\n\n            handler(message).then(() => channelWrapper.ack(data)).catch(() => {});\n          },\n          { noAck: false }\n        )\n      ]).catch(e => {\n        console.error(e);\n      });\n    }\n  });\n\n  // return channelWrapper;\n  return channelWrapper.waitForConnect().then(() => {\n    console.log(`Listening for messages on ${queueName}`);\n  });\n};\n\n/**\n *  Publisher.\n *\n * @param {string} queueName - name of queue.\n * @param {object} [data] - data to be published.\n */\nconst publish = (queueName, data) => {\n  console.log(queueName, data);\n  const channelWrapper = connection.createChannel({\n    json: true,\n    setup(channel) {\n      // `channel` here is a regular amqplib `ConfirmChannel`.\n      return channel.assertQueue(queueName, { durable: true });\n    }\n  });\n\n  // Send messages until someone hits CTRL-C or something goes wrong...\n  const startPublishing = () => {\n    channelWrapper\n      .sendToQueue(queueName, data, { persistent: true })\n      .then(() => {\n        console.log('Message sent');\n        // return wait(1000);\n        return null;\n      })\n      .then(() =>\n        // return sendMessage();\n        Promise.resolve()\n      )\n      .catch(err => {\n        console.log('Message was rejected:', err.stack);\n        channelWrapper.close();\n        connection.close();\n      });\n  };\n\n  startPublishing();\n\n  // return sendMessage;\n};\n\nconst purgeQueue = queueName => {\n  const channelWrapper = connection.createChannel({\n    setup(channel) {\n      // `channel` here is a regular amqplib `ConfirmChannel`.\n      return Promise.all([\n        channel.assertQueue(queueName, { durable: true }),\n        channel.purgeQueue(queueName)\n      ]);\n    }\n  });\n\n  return channelWrapper;\n};\n\nconst ackAll = () => {\n  const channelWrapper = connection.createChannel({\n    setup(channel) {\n      // `channel` here is a regular amqplib `ConfirmChannel`.\n      return channel.ackAll();\n    }\n  });\n\n  return channelWrapper;\n};\n\nmodule.exports = {\n  publish,\n  consume,\n  purgeQueue,\n  ackAll\n};\n\nexport default amqp;\n"]}