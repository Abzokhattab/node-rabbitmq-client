{"version":3,"sources":["../src/index.js"],"names":["logger","global","log","console","error","connect","urls","options","AmqpConnectionManager","env","process","NODE_ENV","currentPath","cwd","config","require","path","join","host","port","username","password","vhost","protocol","prefetch","heartbeatInterval","reconnectTime","defaultQueueFeatures","durable","rabbitMQ","connectionUrl","connection","json","heartbeatIntervalInSeconds","reconnectTimeInSeconds","connectionOptions","on","note","params","err","consume","handler","queueName","queue","name","queueOptions","Promise","reject","Error","channelWrapper","createChannel","setup","channel","all","assertQueue","data","message","JSON","parse","content","toString","then","ack","catch","noAck","e","waitForConnect","publish","startPublishing","sendToQueue","persistent","custom","close","purgeQueue","ackAll","module","exports"],"mappings":"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","file":"index.js","sourcesContent":["import AmqpConnectionManager from './AmqpConnectionManager';\nimport path from 'path';\n\n/** check for logger in the global scope. */\nconst logger = global.logger ? global.logger : { log: console.log, error: console.error };\n\nfunction connect(urls, options) {\n    return new AmqpConnectionManager(urls, options);\n}\n\nconst env = process.env.NODE_ENV || 'development';\nconst currentPath = process.cwd();\n\nconst config = require(path.join(currentPath, 'config', 'env', `${env}`));\n\nconst {\n    host,\n    port,\n    username,\n    password,\n    vhost = '/',\n    protocol = 'amqp',\n    prefetch = 2,\n    heartbeatInterval = 5,\n    reconnectTime = 10,\n    options = {},\n    defaultQueueFeatures = { durable: true }\n} = config.rabbitMQ;\n\n// Handle an incomming message.\n// const onMessage = function(channelWrapper, data) {\n//   const message = JSON.parse(data.content.toString());\n//   console.log(\"receiver: got message\", message);\n//   channelWrapper.ack(data);\n// }\n\nconst connectionUrl = `${protocol}://${username}:${password}@${host}:${port}/${vhost}`;\n\n/**\n * options.heartbeatIntervalInSeconds - Interval to send heartbeats to broker. Defaults to 5 seconds.\n * options.reconnectTimeInSeconds - The time to wait before trying to reconnect. If not specified, defaults to heartbeatIntervalInSeconds.\n * options.findServers(callback) is a function which returns one or more servers to connect to. This should return either a single URL or an array of URLs. This is handy when you're using a service discovery mechanism such as Consul or etcd. Instead of taking a callback, this can also return a Promise. Note that if this is supplied, then urls is ignored.\n * options.connectionOptions is passed as options to the amqplib connect method.\n */\n\n// Create a connetion manager\nconst connection = connect(\n  [connectionUrl],\n  {\n    json: true,\n    heartbeatIntervalInSeconds: heartbeatInterval,\n    reconnectTimeInSeconds: reconnectTime,\n    connectionOptions: options\n  }\n);\n\nconnection.on('connect', () => {\n  logger.log('data', { note: 'Connected to RabbitMQ server' });\n});\n\nconnection.on('disconnect', params => {\n  logger.log('error', { error: params.err, note: 'RabbitMQ server is disconnected' });\n});\n\n/**\n *  Consumer.\n *\n * @param {object} params - object with queue name and queue options.\n * @param {function} [handler] - callback.\n * @returns {void | Promise} - Resolves when complete.\n */\nconst consume = (params = {}, handler) => {\n  const queueName = params.queue && params.queue.name;\n  const queueOptions = params.queue.options || defaultQueueFeatures;\n\n  if (!queueName) {\n    return Promise.reject(new Error('Queue name is missing'));\n  }\n\n  // Set up a channel listening for messages in the queue.\n  const channelWrapper = connection.createChannel({\n    setup(channel) {\n      // `channel` here is a regular amqplib `ConfirmChannel`.\n      return Promise.all([\n        channel.assertQueue(queueName, queueOptions),\n        channel.prefetch(prefetch),\n        // channel.consume(queueName, handler.bind(null, channelWrapper))\n        channel.consume(\n          queueName,\n          data => {\n            const message = JSON.parse(data.content.toString());\n\n            handler(message).then(() => channelWrapper.ack(data)).catch(() => {});\n          },\n          { noAck: false }\n        )\n      ]).catch(e => {\n        logger.log('error', { error: e, note: 'error from consume' });\n      });\n    }\n  });\n\n  /** start the consumer */\n  return channelWrapper.waitForConnect().then(() => {\n    logger.log('data', { note: `Consumption from ${queueName} started!` });\n  });\n};\n\n/**\n *  Publisher.\n *\n * @param {object} params - name of queue.\n * @param {object} [data] - data to be published.\n * @returns {void | Promise} - Resolves when complete.\n */\nconst publish = (params = {}, data) => {\n  const queueName = params.queue && params.queue.name;\n  const queueOptions = params.queue.options || defaultQueueFeatures;\n\n  if (!queueName) {\n    return Promise.reject(new Error('Queue name is missing'));\n  }\n\n  const channelWrapper = connection.createChannel({\n    json: true,\n    setup(channel) {\n      // `channel` here is a regular amqplib `ConfirmChannel`.\n      return channel.assertQueue(queueName, queueOptions);\n    }\n  });\n\n  // Send messages until someone hits CTRL-C or something goes wrong...\n  const startPublishing = () => {\n    channelWrapper\n      .sendToQueue(queueName, data, { persistent: true })\n      .then(() => {\n        logger.log('data', { note: `Message sent to queue ${queueName}` });\n        return null;\n      })\n      .catch(err => {\n        logger.log('error', { note: 'Message was rejected', error: err, custom: { data }});\n        channelWrapper.close();\n        connection.close();\n      });\n  };\n\n  startPublishing();\n\n  // return sendMessage;\n};\n\nconst purgeQueue = queueName => {\n  const channelWrapper = connection.createChannel({\n    setup(channel) {\n      // `channel` here is a regular amqplib `ConfirmChannel`.\n      return Promise.all([\n        channel.assertQueue(queueName, defaultQueueFeatures),\n        channel.purgeQueue(queueName)\n      ]);\n    }\n  });\n\n  return channelWrapper;\n};\n\nconst ackAll = () => {\n  const channelWrapper = connection.createChannel({\n    setup(channel) {\n      // `channel` here is a regular amqplib `ConfirmChannel`.\n      return channel.ackAll();\n    }\n  });\n\n  return channelWrapper;\n};\n\nmodule.exports = {\n  publish,\n  consume,\n  purgeQueue,\n  ackAll\n};\n"]}