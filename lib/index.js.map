{"version":3,"sources":["../src/index.js"],"names":["amqp","require","path","logger","global","env","process","NODE_ENV","currentPath","cwd","config","join","host","port","username","password","vhost","protocol","prefetch","heartbeatInterval","reconnectTime","options","defaultQueueFeatures","durable","rabbitMQ","connectionUrl","connection","connect","json","heartbeatIntervalInSeconds","reconnectTimeInSeconds","connectionOptions","on","log","note","params","error","err","consume","handler","queueName","queue","name","queueOptions","Promise","reject","Error","channelWrapper","createChannel","setup","channel","all","assertQueue","data","message","JSON","parse","content","toString","then","ack","resolve","custom","parsingErrors","publish","noAck","catch","e","waitForConnect","startPublishing","sendToQueue","persistent","close","purgeQueue","ackAll","module","exports"],"mappings":"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","file":"index.js","sourcesContent":["const amqp = require('amqp-connection-manager');\nconst path = require('path');\n\nconst logger = global.logger || require('logstash-winston').logger;\n\nconst env = process.env.NODE_ENV || 'development';\nconst currentPath = process.cwd();\n\nconst config = require(path.join(currentPath, 'config', 'env', `${env}`));\n\nconst {\n  host,\n  port,\n  username,\n  password,\n  vhost = '/',\n  protocol = 'amqp',\n  prefetch = 2,\n  heartbeatInterval = 5,\n  reconnectTime = 10,\n  options = {},\n  defaultQueueFeatures = { durable: true }\n} = config.rabbitMQ;\n\nconst connectionUrl = `${protocol}://${username}:${password}@${host}:${port}/${vhost}`;\n\n/**\n * options.heartbeatIntervalInSeconds - Interval to send heartbeats to broker. Defaults to 5 seconds.\n * options.reconnectTimeInSeconds - The time to wait before trying to reconnect. If not specified, defaults to heartbeatIntervalInSeconds.\n * options.findServers(callback) is a function which returns one or more servers to connect to. This should return either a single URL or an array of URLs. This is handy when you're using a service discovery mechanism such as Consul or etcd. Instead of taking a callback, this can also return a Promise. Note that if this is supplied, then urls is ignored.\n * options.connectionOptions is passed as options to the amqplib connect method.\n */\n\n// Create a connetion manager\nconst connection = amqp.connect(\n  [connectionUrl],\n  {\n    json: true,\n    heartbeatIntervalInSeconds: heartbeatInterval,\n    reconnectTimeInSeconds: reconnectTime,\n    connectionOptions: options\n  }\n);\n\nconnection.on('connect', () => {\n  logger.log('data', { note: 'Connected to RabbitMQ server' });\n});\n\nconnection.on('disconnect', params => {\n  logger.log('error', { error: params.err, note: 'RabbitMQ server is disconnected' });\n});\n\n/**\n *  Consumer.\n *\n * @param {object} params - object with queue name and queue options.\n * @param {function} [handler] - callback.\n * @returns {void | Promise} - Resolves when complete.\n */\nconst consume = (params = {}, handler) => {\n  const queueName = params.queue && params.queue.name;\n  const queueOptions = params.queue.options || defaultQueueFeatures;\n  const queue = config.rabbitMQ;\n\n  if (!queueName) {\n    return Promise.reject(new Error('Queue name is missing'));\n  }\n\n  /** Set up a channel listening for messages in the queue. */\n  const channelWrapper = connection.createChannel({\n    setup(channel) {\n      /** `channel` here is a regular amqplib `ConfirmChannel`. */\n      return Promise.all([\n        channel.assertQueue(queueName, queueOptions),\n        channel.prefetch(prefetch),\n        channel.consume(\n          queueName,\n          data => {\n            let message;\n            try {\n              message = JSON.parse(data.content.toString());\n\n              return handler(message, params)\n                .then(() => {\n                  channelWrapper.ack(data);\n                  return Promise.resolve(data);\n                });\n            } catch (error) {\n              logger.log('error', {\n                error,\n                note: `Got malformed message from queue ${queueName}`,\n                custom: { data: message }\n              });\n\n              if (queue.parsingErrors) {\n                publish(queue.parsingErrors, {\n                  message,\n                  error,\n                  queueName\n                });\n              }\n            }\n          },\n          { noAck: false }\n        )\n      ])\n        /** catch all errors */\n        .catch(e => {\n          logger.log('error', { error: e, note: 'error from consume' });\n        });\n    }\n  });\n\n  /** start the consumer */\n  channelWrapper.waitForConnect()\n    .then(() => {\n      logger.log('data', { note: `Consumption from ${queueName} started!` });\n    })\n    .catch(e => logger.log('error', { error: e, note: 'error from consume' }));\n};\n\n/**\n *  Publisher.\n *\n * @param {object} params - object with queue name and queue options.\n * @param {object} [data] - data to be published.\n * @returns {void | Promise} - Resolves when complete.\n */\nconst publish = (params = {}, data) => {\n  const queueName = params.queue && params.queue.name;\n  const queueOptions = params.queue.options || defaultQueueFeatures;\n\n  if (!queueName) {\n    return Promise.reject(new Error('Queue name is missing'));\n  }\n\n  const channelWrapper = connection.createChannel({\n    json: true,\n    setup(channel) {\n      // `channel` here is a regular amqplib `ConfirmChannel`.\n      return channel.assertQueue(queueName, queueOptions);\n    }\n  });\n\n  const startPublishing = () => {\n    /** returns a <Promise> */\n    return channelWrapper\n      .sendToQueue(queueName, data, { persistent: true })\n      .then(() => {\n        logger.log('data', { note: `Message sent to queue ${queueName}`, custom: { data } });\n        return Promise.resolve(data);\n      })\n      .catch(err => {\n        logger.log('error', { note: 'Message is rejected', error: err, custom: { data }});\n        channelWrapper.close();\n        connection.close();\n        return Promise.reject(err);\n      });\n  };\n\n  /** explicitly return this function*/\n  return startPublishing();\n};\n\n/**\n *  purgeQueue.\n *\n * @param {object} params - object with queue name and queue options.\n * @returns {void | Promise} - Returns resolved promise\n */\nconst purgeQueue = (params ={}) => {\n  const queueName = params.queue && params.queue.name;\n  const queueOptions = params.queue.options || defaultQueueFeatures;\n\n  if (!queueName) {\n    return Promise.reject(new Error('Queue name is missing'));\n  }\n\n  return new Promise(resolve => {\n    connection.createChannel({\n      setup(channel) {\n        // `channel` here is a regular amqplib `ConfirmChannel`.\n        return Promise.all([\n          channel.assertQueue(queueName, queueOptions),\n          channel.purgeQueue(queueName)\n        ]);\n      }\n    });\n\n    return resolve(params);\n  });\n};\n\n/**\n *  ackAll.\n *\n * @returns {void | Promise} - Resolves when complete.\n */\nconst ackAll = () => {\n  return new Promise(resolve => {\n    connection.createChannel({\n      setup(channel) {\n        // `channel` here is a regular amqplib `ConfirmChannel`.\n        return channel.ackAll();\n      }\n    });\n\n    return resolve();\n  });\n};\n\nmodule.exports = {\n  connection,\n  publish,\n  consume,\n  purgeQueue,\n  ackAll\n};\n"]}