{"version":3,"sources":["../src/index.js"],"names":["amqp","require","path","logger","global","env","process","NODE_ENV","currentPath","cwd","config","join","e","console","warn","host","port","username","password","vhost","protocol","prefetch","heartbeatInterval","reconnectTime","options","defaultQueueFeatures","durable","rabbitMQ","connectionUrl","connection","connect","json","heartbeatIntervalInSeconds","reconnectTimeInSeconds","connectionOptions","on","log","note","params","error","err","consume","handler","queueName","queue","name","queueOptions","Promise","reject","Error","channelWrapper","createChannel","setup","channel","all","assertQueue","data","message","JSON","parse","content","toString","then","ack","resolve","custom","parsingErrors","publish","noAck","catch","waitForConnect","messagePriority","publishOptions","persistent","Number","priority","startPublishing","sendToQueue","close","purgeQueue","ackAll","module","exports"],"mappings":"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","file":"index.js","sourcesContent":["const amqp = require('amqp-connection-manager');\nconst path = require('path');\n\nconst logger = global.logger || require('logstash-winston').logger;\n\nconst env = process.env.NODE_ENV || 'development';\nconst currentPath = process.cwd();\n\nlet config;\n\ntry {\n  config = require(path.join(currentPath, 'config', 'env', `${env}`));\n} catch (e) {\n  // eslint-disable-next-line no-console\n  console.warn(`config is not found at /config/env/${env}, checking for config at  /src/config/env/${env}`);\n  config = require(path.join(currentPath, 'src', 'config', 'env', `${env}`));\n}\n\nconst {\n  host,\n  port,\n  username,\n  password,\n  vhost = '/',\n  protocol = 'amqp',\n  prefetch = 2,\n  heartbeatInterval = 5,\n  reconnectTime = 10,\n  options = {},\n  defaultQueueFeatures = { durable: true }\n} = config.rabbitMQ;\n\nconst connectionUrl = `${protocol}://${username}:${password}@${host}:${port}/${vhost}`;\n\n/**\n * options.heartbeatIntervalInSeconds - Interval to send heartbeats to broker. Defaults to 5 seconds.\n * options.reconnectTimeInSeconds - The time to wait before trying to reconnect. If not specified, defaults to heartbeatIntervalInSeconds.\n * options.findServers(callback) is a function which returns one or more servers to connect to. This should return either a single URL or an array of URLs. This is handy when you're using a service discovery mechanism such as Consul or etcd. Instead of taking a callback, this can also return a Promise. Note that if this is supplied, then urls is ignored.\n * options.connectionOptions is passed as options to the amqplib connect method.\n */\n\n// Create a connetion manager\nconst connection = amqp.connect(\n  [connectionUrl],\n  {\n    json: true,\n    heartbeatIntervalInSeconds: heartbeatInterval,\n    reconnectTimeInSeconds: reconnectTime,\n    connectionOptions: options\n  }\n);\n\nconnection.on('connect', () => {\n  logger.log('data', { note: 'Connected to RabbitMQ server' });\n});\n\nconnection.on('disconnect', params => {\n  logger.log('error', { error: params.err, note: 'RabbitMQ server is disconnected' });\n});\n\n/**\n *  Consumer.\n *\n * @param {object} params - object with queue name and queue options.\n * @param {function} [handler] - callback.\n * @returns {void | Promise} - Resolves when complete.\n */\nconst consume = (params = {}, handler) => {\n  const queueName = params.queue && params.queue.name;\n  const queueOptions = params.queue.options || defaultQueueFeatures;\n  const queue = config.rabbitMQ;\n\n  if (!queueName) {\n    return Promise.reject(new Error('Queue name is missing'));\n  }\n\n  /** Set up a channel listening for messages in the queue. */\n  const channelWrapper = connection.createChannel({\n    setup(channel) {\n      /** `channel` here is a regular amqplib `ConfirmChannel`. */\n      return Promise.all([\n        channel.assertQueue(queueName, queueOptions),\n        channel.prefetch(prefetch),\n        channel.consume(\n          queueName,\n          data => {\n            let message;\n            try {\n              message = JSON.parse(data.content.toString());\n\n              return handler(message, params)\n                .then(() => {\n                  channelWrapper.ack(data);\n                  return Promise.resolve(data);\n                });\n            } catch (error) {\n              logger.log('error', {\n                error,\n                note: `Got malformed message from queue ${queueName}`,\n                custom: { data: message }\n              });\n\n              if (queue.parsingErrors) {\n                publish(queue.parsingErrors, {\n                  message,\n                  error,\n                  queueName\n                });\n              }\n            }\n          },\n          { noAck: false }\n        )\n      ])\n        /** catch all errors */\n        .catch(e => {\n          logger.log('error', { error: e, note: 'error from consume' });\n        });\n    }\n  });\n\n  /** start the consumer */\n  channelWrapper.waitForConnect()\n    .then(() => {\n      logger.log('data', { note: `Consumption from ${queueName} started!` });\n    })\n    .catch(e => logger.log('error', { error: e, note: 'error from consume' }));\n};\n\n/**\n *  Publisher.\n *\n * @param {object} params - object with queue name and queue options.\n * @param {object} [data] - data to be published.\n * @returns {void | Promise} - Resolves when complete.\n */\nconst publish = (params = {}, data) => {\n  const queueName = params.queue && params.queue.name;\n  const queueOptions = params.queue.options || defaultQueueFeatures;\n\n  if (!queueName) {\n    return Promise.reject(new Error('Queue name is missing'));\n  }\n\n  // consider message priority if provided\n  const messagePriority = params.queue.messagePriority;\n  const publishOptions = { persistent: true };\n\n  if (Number(messagePriority) > 0) publishOptions.priority = messagePriority;\n\n  const channelWrapper = connection.createChannel({\n    json: true,\n    setup(channel) {\n      // `channel` here is a regular amqplib `ConfirmChannel`.\n      return channel.assertQueue(queueName, queueOptions);\n    }\n  });\n\n  const startPublishing = () => {\n    /** returns a <Promise> */\n    return channelWrapper\n      .sendToQueue(queueName, data, publishOptions)\n      .then(() => {\n        logger.log('data', { note: `Message sent to queue ${queueName}`, custom: { data } });\n        return Promise.resolve(data);\n      })\n      .catch(err => {\n        logger.log('error', { note: 'Message is rejected', error: err, custom: { data }});\n        channelWrapper.close();\n        connection.close();\n        return Promise.reject(err);\n      });\n  };\n\n  /** explicitly return this function*/\n  return startPublishing();\n};\n\n/**\n *  purgeQueue.\n *\n * @param {object} params - object with queue name and queue options.\n * @returns {void | Promise} - Returns resolved promise\n */\nconst purgeQueue = (params ={}) => {\n  const queueName = params.queue && params.queue.name;\n  const queueOptions = params.queue.options || defaultQueueFeatures;\n\n  if (!queueName) {\n    return Promise.reject(new Error('Queue name is missing'));\n  }\n\n  return new Promise(resolve => {\n    connection.createChannel({\n      setup(channel) {\n        // `channel` here is a regular amqplib `ConfirmChannel`.\n        return Promise.all([\n          channel.assertQueue(queueName, queueOptions),\n          channel.purgeQueue(queueName)\n        ]);\n      }\n    });\n\n    return resolve(params);\n  });\n};\n\n/**\n *  ackAll.\n *\n * @returns {void | Promise} - Resolves when complete.\n */\nconst ackAll = () => {\n  return new Promise(resolve => {\n    connection.createChannel({\n      setup(channel) {\n        // `channel` here is a regular amqplib `ConfirmChannel`.\n        return channel.ackAll();\n      }\n    });\n\n    return resolve();\n  });\n};\n\nmodule.exports = {\n  connection,\n  publish,\n  consume,\n  purgeQueue,\n  ackAll\n};\n"]}