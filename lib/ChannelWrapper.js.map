{"version":3,"sources":["../src/ChannelWrapper.js"],"names":["ChannelWrapper","EventEmitter","addSetup","setup","done","pb","addCallback","_settingUp","Promise","resolve","then","_setups","push","_channel","call","undefined","removeSetup","teardown","filter","s","waitForConnect","once","publish","exchange","routingKey","content","options","reject","_messages","type","_startWorker","sendToQueue","queue","constructor","connectionManager","_onConnect","bind","_onDisconnect","_connectionManager","name","_json","json","_working","_workerNumber","isConnected","connection","_currentConnection","on","_connection","createConfirmChannel","channel","_onChannelClose","all","map","setupFn","catch","err","emit","queueLength","length","close","forEach","message","Error","removeListener","answer","_shouldPublish","_publishQueuedMessages","workerNumber","encodedMessage","Buffer","from","JSON","stringify","sendPromise","result","setImmediate","shift","ack","apply","arguments","nack"],"mappings":"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","file":"ChannelWrapper.js","sourcesContent":["import { EventEmitter } from 'events';\nimport pb from 'promise-breaker';\n\n/**\n *  Calls to `publish()` or `sendToQueue()` work just like in amqplib, but messages are queued internally and\n * are guaranteed to be delivered.  If the underlying connection drops, ChannelWrapper will wait for a new\n * connection and continue.\n *\n * Events:\n * * `connect` - emitted every time this channel connects or reconnects.\n * * `error(err, {name})` - emitted if an error occurs setting up the channel.\n * * `drop({message, err})` - called when a JSON message was dropped because it could not be encoded.\n * * `close` - emitted when this channel closes via a call to `close()`\n *\n */\nexport default class ChannelWrapper extends EventEmitter {\n    /**\n     *  Adds a new 'setup handler'.\n     *\n     * `setup(channel, [cb])` is a function to call when a new underlying channel is created - handy for asserting\n     * exchanges and queues exists, and whatnot.  The `channel` object here is a ConfigChannel from amqplib.\n     * The `setup` function should return a Promise (or optionally take a callback) - no messages will be sent until\n     * this Promise resolves.\n     *\n     * If there is a connection, `setup()` will be run immediately, and the addSetup Promise/callback won't resolve\n     * until `setup` is complete.  Note that in this case, if the setup throws an error, no 'error' event will\n     * be emitted, since you can just handle the error here (although the `setup` will still be added for future\n     * reconnects, even if it throws an error.)\n     *\n     * Setup functions should, ideally, not throw errors, but if they do then the ChannelWrapper will emit an 'error'\n     * event.\n     *\n     * @param {function} setup - setup function.\n     * @param {function} [done] - callback.\n     * @returns {void | Promise} - Resolves when complete.\n     */\n    addSetup(setup, done=null) {\n        return pb.addCallback(done,\n            (this._settingUp || Promise.resolve())\n            .then(() => {\n                this._setups.push(setup);\n                if(this._channel) {\n                    return pb.call(setup, null, this._channel);\n                } else {\n                    return undefined;\n                }\n            })\n        );\n    }\n\n    /**\n     * Remove a setup function added with `addSetup`.  If there is currently a\n     * connection, `teardown(channel, [cb])` will be run immediately, and the\n     * returned Promise will not resolve until it completes.\n     *\n     * @param {function} setup - the setup function to remove.\n     * @param {function} [teardown] - `function(channel, [cb])` to run to tear\n     *   down the chanel.\n     * @param {function} [done] - Optional callback.\n     * @returns {void | Promise} - Resolves when complete.\n     */\n    removeSetup(setup, teardown=null, done=null) {\n        return pb.addCallback(done, () => {\n            this._setups = this._setups.filter(s => s !== setup);\n\n            return (this._settingUp || Promise.resolve())\n            .then(() => this._channel\n                ? pb.call(teardown, null, this._channel)\n                : undefined\n            );\n        });\n    }\n\n    /**\n     * Returns a Promise which resolves when this channel next connects.\n     * (Mainly here for unit testing...)\n     *\n     * @param {function} [done] - Optional callback.\n     * @returns {void | Promise} - Resolves when connected.\n     */\n    waitForConnect(done=null) {\n        return pb.addCallback(done,\n            (this._channel && !this._settingUp)\n                ? Promise.resolve()\n                : new Promise(resolve => this.once('connect', resolve))\n        );\n    }\n\n    /*\n     * Publish a message to the channel.\n     *\n     * This works just like amqplib's `publish()`, except if the channel is not\n     * connected, this will wait until the channel is connected.  Returns a\n     * Promise which will only resolve when the message has been succesfully sent.\n     * The returned promise will be rejected if `close()` is called on this\n     * channel before it can be sent, if `options.json` is set and the message\n     * can't be encoded, or if the broker rejects the message for some reason.\n     *\n     */\n    publish(exchange, routingKey, content, options, done=null) {\n        return pb.addCallback(done, new Promise((resolve, reject) => {\n            this._messages.push({\n                type: 'publish',\n                exchange,\n                routingKey,\n                content,\n                options,\n                resolve,\n                reject\n            });\n            this._startWorker();\n        }));\n    }\n\n    /*\n     * Send a message to a queue.\n     *\n     * This works just like amqplib's `sendToQueue`, except if the channel is not connected, this will wait until the\n     * channel is connected.  Returns a Promise which will only resolve when the message has been succesfully sent.\n     * The returned promise will be rejected only if `close()` is called on this channel before it can be sent.\n     *\n     * `message` here should be a JSON-able object.\n     */\n    sendToQueue(queue, content, options, done=null) {\n        return pb.addCallback(done, new Promise((resolve, reject) => {\n            this._messages.push({\n                type: 'sendToQueue',\n                queue,\n                content,\n                options,\n                resolve,\n                reject\n            });\n            return this._startWorker();\n        }));\n    }\n\n    /**\n     * Create a new ChannelWrapper.\n     *\n     * @param {AmqpConnectionManager} connectionManager - connection manager which\n     *   created this channel.\n     * @param {Object} [options] -\n     * @param {string} [options.name] - A name for this channel.  Handy for debugging.\n     * @param {function} [options.setup] - A default setup function to call.  See\n     *   `addSetup` for details.\n     * @param {boolean} [options.json] - if true, then ChannelWrapper assumes all\n     *   messages passed to `publish()` and `sendToQueue()` are plain JSON objects.\n     *   These will be encoded automatically before being sent.\n     *\n     */\n    constructor(connectionManager, options = {}) {\n        super();\n        this._onConnect = this._onConnect.bind(this);\n        this._onDisconnect = this._onDisconnect.bind(this);\n        this._connectionManager = connectionManager;\n        this.name = options.name;\n\n        this._json = ('json' in options) ? options.json : false;\n\n        // Place to store queued messages.\n        this._messages = [];\n\n        // True if the \"worker\" is busy sending messages.  False if we need to\n        // start the worker to get stuff done.\n        this._working = false;\n\n        // If we're in the process of creating a channel, this is a Promise which\n        // will resolve when the channel is set up.  Otherwise, this is `null`.\n        this._settingUp = null;\n\n        // The currently connected channel.  Note that not all setup functions\n        // have been run on this channel until `@_settingUp` is either null or\n        // resolved.\n        this._channel = null;\n\n        // We kill off workers when we disconnect.  Whenever we start a new\n        // worker, we bump up the `_workerNumber` - this makes it so if stale\n        // workers ever do wake up, they'll know to stop working.\n        this._workerNumber = 0;\n\n        // Array of setup functions to call.\n        this._setups = [];\n        if(options.setup) {\n            this._setups.push(options.setup);\n        }\n\n        if(connectionManager.isConnected()) {\n            this._onConnect({\n                connection: this._connectionManager._currentConnection\n            });\n        }\n        connectionManager.on('connect', this._onConnect);\n        connectionManager.on('disconnect', this._onDisconnect);\n    }\n\n    // Called whenever we connect to the broker.\n    _onConnect({ connection }) {\n        this._connection = connection;\n\n        return connection.createConfirmChannel()\n        .then(channel => {\n            this._channel = channel;\n            channel.on('close', () => this._onChannelClose(channel));\n\n            this._settingUp = Promise.all(\n                this._setups.map(setupFn =>\n                    // TODO: Use a timeout here to guard against setupFns that never resolve?\n                    pb.call(setupFn, null, channel)\n                    .catch(err => {\n                        if(this._channel) {\n                            this.emit('error', err, { name: this.name });\n                        } else {\n                            // Don't emit an error if setups failed because the channel was closing.\n                        }\n                    })\n                )\n\n            )\n            .then(() => {\n                this._settingUp = null;\n                return this._channel;\n            });\n\n            return this._settingUp;\n        })\n        .then(() => {\n            if(!this._channel) {\n                // Can happen if channel closes while we're setting up.\n                return;\n            }\n\n            // Since we just connected, publish any queued messages\n            this._startWorker();\n            this.emit('connect');\n        })\n        .catch(err => {\n            this.emit('error', err, { name: this.name });\n            this._settingUp = null;\n            this._channel = null;\n        });\n    }\n\n    // Called whenever the channel closes.\n    _onChannelClose(channel) {\n        if(this._channel === channel) {\n            this._channel = null;\n        }\n    }\n    // Wait for another reconnect to create a new channel.\n\n    // Called whenever we disconnect from the AMQP server.\n    _onDisconnect() {\n        this._channel = null;\n        this._settingUp = null;\n\n        // Kill off the current worker.  We never get any kind of error for messages in flight - see\n        // https://github.com/squaremo/amqp.node/issues/191.\n        this._working = false;\n    }\n\n    // Returns the number of unsent messages queued on this channel.\n    queueLength() {\n        return this._messages.length;\n    }\n\n    // Destroy this channel.\n    //\n    // Any unsent messages will have their associated Promises rejected.\n    //\n    close() {\n        return Promise.resolve()\n        .then(() => {\n            this._working = false;\n            if(this._messages.length !== 0) {\n                // Reject any unsent messages.\n                this._messages.forEach(message => message.reject(new Error('Channel closed')));\n            }\n\n            this._connectionManager.removeListener('connect', this._onConnect);\n            this._connectionManager.removeListener('disconnect', this._onDisconnect);\n            const answer = (this._channel && this._channel.close()) || undefined;\n            this._channel = null;\n\n            this.emit('close');\n\n            return answer;\n        });\n    }\n\n    _shouldPublish() {\n        return (this._messages.length > 0) && !this._settingUp && this._channel;\n    }\n\n    // Start publishing queued messages, if there isn't already a worker doing this.\n    _startWorker() {\n        if(!this._working && this._shouldPublish()) {\n            this._working = true;\n            this._workerNumber++;\n            this._publishQueuedMessages(this._workerNumber);\n        }\n    }\n\n    _publishQueuedMessages(workerNumber) {\n        if(!this._shouldPublish() || !this._working || (workerNumber !== this._workerNumber)) {\n            // Can't publish anything right now...\n            this._working = false;\n            return Promise.resolve();\n        }\n\n        const channel = this._channel;\n        const message = this._messages[0];\n\n        Promise.resolve()\n        .then(() => {\n            const encodedMessage = this._json ? new Buffer.from(JSON.stringify(message.content)) : message.content;\n\n            const sendPromise = (() => {\n                switch (message.type) {\n                    case 'publish':\n                        return new Promise(function(resolve, reject) {\n                            const result = channel.publish(message.exchange, message.routingKey, encodedMessage,\n                                message.options,\n                                err => {\n                                    if(err) {\n                                        reject(err);\n                                    } else {\n                                        setImmediate(() => resolve(result));\n                                    }\n                                });\n                        });\n                    case 'sendToQueue':\n                        return new Promise(function(resolve, reject) {\n                            const result = channel.sendToQueue(message.queue, encodedMessage, message.options, err => {\n                                if(err) {\n                                    reject(err);\n                                } else {\n                                    setImmediate(() => resolve(result));\n                                }\n                            });\n                        });\n\n                    /* istanbul ignore next */\n                    default:\n                        throw new Error(`Unhandled message type ${message.type}`);\n                }\n            })();\n\n            return sendPromise;\n        })\n        .then(\n            result => {\n                this._messages.shift();\n                message.resolve(result);\n\n                // Send some more!\n                this._publishQueuedMessages(workerNumber);\n            },\n\n            err => {\n                if(!this._channel) {\n                    // Tried to write to a closed channel.  Leave the message in the queue and we'll try again when we\n                    // reconnect.\n                } else {\n                    // Something went wrong trying to send this message - could be JSON.stringify failed, could be the\n                    // broker rejected the message.  Either way, reject it back\n                    this._messages.shift();\n                    message.reject(err);\n\n                    // Send some more!\n                    this._publishQueuedMessages(workerNumber);\n                }\n            }\n        )\n        .catch( /* istanbul ignore next */ err => {\n            this.emit('error', err);\n            this._working = false;\n        });\n\n        return null;\n    }\n\n    // Send an `ack` to the underlying channel.\n    ack() {\n        return this._channel && this._channel.ack.apply(this._channel, arguments);\n    }\n\n    // Send a `nack` to the underlying channel.\n    nack() {\n        return this._channel && this._channel.nack.apply(this._channel, arguments);\n    }\n}\n"]}